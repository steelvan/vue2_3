
# Входные параметры


> Подразумевается, что вы уже изучили и разобрались с разделом [Основы компонентов](components.md). Если нет — прочитайте его сначала.

## Стиль именования входных параметров (camelCase в сравнении с kebab-case)

Имена HTML-атрибутов являются регистро-независимыми, поэтому обозреватели понимают любые прописные символы как строчные. Это означает, что при использовании шаблонов в DOM входные параметры в camelCase-стиле должны использовать свои эквиваленты в стиле kebab-case (разделённые дефисами):

{% raw %}
```js
Vue.component('blog-post', {
  // camelCase в JavaScript
  props: ['postTitle'],
  template: '<h3>{{ postTitle }}</h3>'
})
```
{% endraw %}

```html
<!-- kebab-case в HTML -->
<blog-post post-title="hello!"></blog-post>
```

Опять же, если вы используете строковые шаблоны, то это ограничение не применяется.

## Указание типа входных параметров

До сих пор мы видели только входные параметры, перечисленные в виде массива строк:

```js
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']
```

Однако лучше, когда каждый входной параметр будет определённого типа. В этих случаях вы можете перечислить входные параметры объектом, где свойство и значение будут содержать информацию об имени входного параметра и его типе, соответственно:

```js
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // или любой другой конструктор
}
```

Это не только документирует ваш компонент, но также предупреждает пользователей в консоли JavaScript обозревателя, если они передают неправильный тип. Вы узнаете гораздо больше о [проверках типов и других проверках входных параметров](#Валидация-входных-параметров) дальше на этой странице.

## Передача статических и динамических входных параметров

До сих пор вы встречали, что во входные параметры передавались статические значения, например:

```html
<blog-post title="My journey with Vue"></blog-post>
```

Вы также встречали входные параметры, присваивающие динамическое значение с помощью `v-bind`, например:

```html
<!-- Динамически присваиваем значение переменной -->
<blog-post v-bind:title="post.title"></blog-post>

<!-- Динамически присваиваем значение комплексного выражения -->
<blog-post
  v-bind:title="post.title + ' написанный ' + post.author.name"
></blog-post>
```

В этих двух примерах мы передаём строковые значения, но могут передаваться значения _любого типа_ во входной параметр.

### Передача чисел

```html
<!-- Несмотря на то, что `42` статическое значение, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post v-bind:likes="42"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post v-bind:likes="post.likes"></blog-post>
```

### Передача булевых значений

```html
<!-- Указание входного параметра без значения будет означать `true`. -->
<blog-post is-published></blog-post>

<!-- Несмотря на то, что `false` статическое значение, нам нужен v-bind -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.     -->
<blog-post v-bind:is-published="false"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post v-bind:is-published="post.currentUserFavorited"></blog-post>
```

### Передача массивов

```html
<!-- Несмотря на то, что указан статический массив, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post v-bind:comment-ids="[234, 266, 273]"></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post v-bind:comment-ids="post.commentIds"></blog-post>
```

### Передача объектов

```html
<!-- Несмотря на то, что указан статический объект, нам нужен v-bind, -->
<!-- чтобы сообщить Vue, что это выражение JavaScript, а не строка.   -->
<blog-post
  v-bind:author="{ name: 'Veronica', company: 'Veridian Dynamics' }"
></blog-post>

<!-- Динамическое присвоение значения переменной. -->
<blog-post v-bind:author="post.author"></blog-post>
```

### Передача свойств объекта

Если вы хотите передать все свойства объекта в качестве входных параметров, вы можете использовать `v-bind` без аргументов (`v-bind` вместо `v-bind:prop-name`). Например, для объекта `post`:

```js
post: {
  id: 1,
  title: 'My Journey with Vue'
}
```

Следующий шаблон:

```html
<blog-post v-bind="post"></blog-post>
```

Будет аналогичен:

```html
<blog-post
  v-bind:id="post.id"
  v-bind:title="post.title"
></blog-post>
```

## Однонаправленный поток данных

Все входные параметры образуют **одностороннюю привязку** между дочерним свойством и родительским: когда родительское свойство обновляется — оно будет передаваться дочернему, но не наоборот. Это предотвращает случайное изменение дочерними компонентами родительского состояния, что может затруднить понимание потока данных вашего приложения.

Кроме того, каждый раз, когда обновляется родительский компонент, все входные параметры дочернего компонента будут обновлены насущными значениями. Это означает, что вы **не должны** пытаться изменять входной параметр внутри дочернего компонента. Если вы это сделаете, Vue отобразит предупреждение в консоли.

Обычно встречаются два случая, когда возникает соблазн изменять входной параметр:

1. **Входной параметр используется для передачи начального значения; дочерний компонент хочет использовать его как местное свойство данных в дальнейшем.** В этом случае лучше всего определить местное свойство в данных, которое использует значение входного параметра в качестве начального:

  ```js
  props: ['initialCounter'],
  data: function () {
    return {
      counter: this.initialCounter
    }
  }
  ```

2. **Входной параметр передаётся как необработанное значение, которое необходимо преобразовать.** В этом случае лучше всего определить вычисляемое свойство с использованием входного параметра:

  ```js
  props: ['size'],
  computed: {
    normalizedSize: function () {
      return this.size.trim().toLowerCase()
    }
  }
  ```

Обратите внимание, что объекты и массивы в JavaScript передаются по ссылке, поэтому если входной параметр является массивом или объектом, то изменение объекта или массива внутри дочернего компонента **будет влиять** на состояние родителя.

## Проверка входных параметров

Компоненты могут указывать требования к своим входным параметрам, такие как определение типа, которые вы уже видели. Если эти требования не выполнены — Vue предупредит вас сообщением в JavaScript-консоли обозревателя. Это особенно полезно при разработке компонента, который предназначен для использования другими.

Чтобы указать проверки входного параметра, вы можете предоставить в `props` объект с проверками для проверки значения, вместо массива строк. Например:

```js
Vue.component('my-component', {
  props: {
    // Просто проверка типа (`null` и `undefined` проходят проверку для любого типа)
    propA: Number,
    // Несколько допустимых типов
    propB: [String, Number],
    // Обязательное значение строкового типа
    propC: {
      type: String,
      required: true
    },
    // Число со значением по умолчанию
    propD: {
      type: Number,
      default: 100
    },
    // Объект со значением по умолчанию
    propE: {
      type: Object,
      // Для объектов или массивов значения по умолчанию
      // должны возвращаться из функции
      default: function () {
        return { message: 'hello' }
      }
    },
    // Пользовательская функция для проверки
    propF: {
      validator: function (value) {
        // Значение должно соответствовать одной из этих строк
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    }
  }
})
```

Когда проверка входного параметра заканчивается ошибкой — Vue выдаст предупреждение в консоли (если используется сборка для разработки).

Обратите внимание, что входные параметры проверяются **перед** созданием экземпляра компонента, поэтому свойства экземпляра (например, `data`, `computed` и т.д.) не будут доступны внутри `default` или функций `validator`.

### Проверка типа

Значением `type` может быть один из следующих родных конструкторов:

- String
- Number
- Boolean
- Array
- Object
- Date
- Function
- Symbol

Кроме того, `type` также может быть пользовательской функцией-конструктором и проверка будет выполняться проверкой с помощью `instanceof`. Например, если существует следующая функция-конструктор:

```js
function Person (firstName, lastName) {
  this.firstName = firstName
  this.lastName = lastName
}
```

Вы можете использовать:

```js
Vue.component('blog-post', {
  props: {
    author: Person
  }
})
```

чтобы проверить, что значение входного параметра `author` было создано с помощью `new Person`.

## Передача обычных атрибутов

Обычные атрибуты — это атрибуты, передаваемые в компонент, но не имеющие определения соответствующего входного параметра в компоненте.

Хотя явно определённые свойства предпочтительны для передачи информации дочернему компоненту, авторы библиотек компонентов не всегда могут предвидеть все контексты, в которых будут использованы их компоненты. Вот почему компоненты могут принимать произвольные атрибуты, которые добавляются в корневой элемент компонента.

Например, представьте, что мы используем сторонний компонент `bootstrap-date-input` с добавкой Bootstrap, который требует указания атрибута `data-date-picker` на элементе `input`. Мы можем добавить этот атрибут к нашему экземпляру компонента:

```html
<bootstrap-date-input data-date-picker="activated"></bootstrap-date-input>
```

И атрибут `data-date-picker="activated"` будет автоматически добавлен в корневой элемент `bootstrap-date-input`.

### Замена/Объединение существующих атрибутов

Представьте, что это шаблон для `bootstrap-date-input`:

```html
<input type="date" class="form-control">
```

Чтобы добавить тему для нашей добавки выбора даты, нам может понадобиться добавить определённый класс, например:

```html
<bootstrap-date-input
  data-date-picker="activated"
  class="date-picker-theme-dark"
></bootstrap-date-input>
```

В этом случае определены два разных значения для `class`:

- `form-control`, который задаётся компонентом в его шаблоне
- `date-picker-theme-dark`, который передаётся компоненту его родителем

Для большинства атрибутов значение, предоставляемое компоненту, будет заменять значение, заданное компонентом. Например, передача `type="text"` будет заменять `type="date"` и, вероятно, ломать всё! К счастью, работа с атрибутами `class` и `style` немного умнее, поэтому оба значения будут объединены в итоговое: `form-control date-picker-theme-dark`.

### Отключение наследования атрибутов

Если вы **не хотите**, чтобы корневой элемент компонента наследовал атрибуты, вы можете установить `inheritAttrs: false` в настройках компонента. Например:

```js
Vue.component('my-component', {
  inheritAttrs: false,
  // ...
})
```

Это может быть особенно полезно в сочетании со свойством экземпляра `$attrs`, которое содержит имена атрибутов и значения, переданные компоненту, например:

```js
{
  required: true,
  placeholder: 'Введите имя пользователя'
}
```

С помощью `inheritAttrs: false` и `$attrs` вы можете вручную определять к какому элементу должны применяться атрибуты, что часто требуется для [базовых компонентов](./style-guide.html#Именование-базовых-компонентов-настоятельно-рекомендуется):

{% raw %}
```js
Vue.component('base-input', {
  inheritAttrs: false,
  props: ['label', 'value'],
  template: `
    <label>
      {{ label }}
      <input
        v-bind="$attrs"
        v-bind:value="value"
        v-on:input="$emit('input', $event.target.value)"
      >
    </label>
  `
})
```
{% endraw %}

Обратите внимание, что параметр `inheritAttrs: false` **не влияет** на привязки `style` и `class`.

Этот шаблон позволяет вам использовать базовые компоненты больше как обычные HTML-элементы, не беспокоясь о том, какой элемент будет у него корневым:

```html
<base-input
  label="Пользователь:"
  v-model="username"
  required
  placeholder="Введите имя пользователя"
></base-input>
```
